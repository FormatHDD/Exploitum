import struct
import sys
import argparse
import Queue
import urllib

print("Exploitum v1.0 created by Format_HDD")

cv = "v1.0"

try:
    v = urllib.urlopen("https://format-hdd.000webhostapp.com/exploitum_newest_version.txt").read().strip()
    if cv != v:
        print("!!! UPDATE AVIABLE !!!\nVISIT https://github.com/FormatHDD/Exploitum AND DOWNLOAD THE NEW FILE.")
except:
    # :P
    pass

def createPattern(size, parser):
    try:
        size = int(size)
        pattern = ''
        parts = ['A', 'a', '0']
        while len(pattern) != size:
            pattern += parts[len(pattern) % 3]
            if len(pattern) % 3 == 0:
                parts[2] = chr(ord(parts[2]) + 1)
                if parts[2] > '9':
                    parts[2] = '0'
                    parts[1] = chr(ord(parts[1]) + 1)
                    if parts[1] > 'z':
                        parts[1] = 'a'
                        parts[0] = chr(ord(parts[0]) + 1)
                        if parts[0] > 'Z':
                            parts[0] = 'A'
        return pattern
    except:
        parser.print_help()
        return

def checkPattern(size, string, parser):
    try:
        if string.startswith('0x'):
            string = struct.pack('<I', int(string, 16)).strip('\x00')
        pattern = createPattern(size, parser)
        try:
            #print(string[::-1])
            return pattern.index(string)
        except ValueError:
            return 'Not found'
    except:
        parser.print_help()
        return

def xorstr(s1, s2):
    return "".join(chr(ord(s1[i])^ord(s2[i])) for i in range(len(s1)))

def findValidXor(address):
    base = struct.unpack("I", "\x01\x01\x01\x01")[0]
    while True:
        if "\x00" in xorstr(struct.pack("I", base), address) or "\x00" in struct.pack("I", base):
            base += 1
        else:
            return struct.pack("I", base)

def isonly(string, char):
    isOnly = True
    for c in string:
        if c != char:
            isOnly = False
    return isOnly

def xorit(register):
    return "\txor\t{},\t{}\n".format(register, register)

def validateBytes(buffer, register, buffertype):
    #print(register)
    buffertype = buffertype.lower()
    if isonly(buffer, "0"):
        return xorit(register)
    elif buffertype == "byte[]":
        register_queue = Queue.Queue()
        registers_used = []
        for register_ in ["eax", "ebx", "ecx", "edx", "esi", "edi"]:
            register_queue.put(register_)
        ret = "\txor\tebp,\tebp"
        #print(buffer)
        arguments_buf = buffer.split(",")
        arguments = []
        for argument in arguments_buf:
            if not register_queue.empty():
                argument_asm = "\n\tpush\tebp"
                argument_hex = argument.encode("hex")
                argument_buf = []
                argument_buf2= [argument[i:i+4] for i in range(0, len(argument), 4)]
                #print(argument_buf2)
                for arg in argument_buf2:
                    argument_buf.append(("\x00"*(4-len(arg))+arg[::-1]))
                argument_buf = argument_buf[::-1]
                for arg in argument_buf:
                    if "\x00" in arg:
                        #print(argument_buf)
                        xorBase = findValidXor(arg)
                        argument_asm += "\n\tpush\t{}\n\txor\tdword ptr [esp],\t{}".format("0x"+xorBase.encode("hex"), "0x"+xorstr(xorBase, arg).encode("hex"))
                    else:
                        argument_asm += "\n\tpush\t{}".format("0x"+arg.encode("hex"))
                reg_ = register_queue.get()
                registers_used.append(reg_)
                argument_asm += "\n\tmov\t{},\tesp".format(reg_)
                ret += argument_asm
            else:
                print("[!!!] Error: Too many values in array. Max: 6")
                sys.exit()
        ret += "\n\tpush\tebp"
        #print(registers_used)
        for register_used in registers_used[::-1]:
            ret += "\n\tpush\t{}".format(register_used)
        ret += "\n\tmov\t{},\tesp\n".format(register)     #somehow wrong register?!?
        return ret
    elif buffertype == "hex":
        if buffer.startswith("0x"):
            if isonly(buffer[2:], "0"):
                return xorit(register)
    if buffertype == "hex":
        if buffer.startswith("0x"):
            buffer = buffer[2:]
        if len(buffer) %2 != 0:
            print("[!!!] Error: couldn't decode hex.")
            sys.exit()
        else:
            buffer = buffer.decode("hex")
            if len(buffer) == 1:
                return "\tpush\t{}\n\tpop\t{}\n".format("0x"+buffer.encode("hex"), register)

    if buffertype == "loc" and buffer.lower() in ["eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", "eip", "ax", "bx", "cx", "dx", "ah", "al", "bh", "bl", "ch", "cl", "dh", "dl"]:
        return "\tpush\t{}\n\tpop\t{}\n".format(buffer, register)
    elif buffertype == "int":
        try:
            a = int(buffer)
            return "\tpush\t{}\n\tpop\t{}\n".format(buffer, register)
        except:
            print("[!!!] Error: argument is not an integer.")
            sys.exit()
    else:
        data_pieces_temp = [(buffer[i:i+4]) for i in range(0, len(buffer), 4)]
        data_pieces = []
        for data_piece in data_pieces_temp:
            if buffertype == "byte":
                data_piece = data_piece[::-1]
            data_pieces.append(("\x00"*(4-len(data_piece)))+data_piece)
        data_pieces = data_pieces[::-1]
        ret = "\tpush\t1\n\tdec\tbyte ptr [esp]\n"
        for data_piece in data_pieces:
            if "\x00" in data_piece:
                xorer = findValidXor(data_piece)
                ret += "\tpush\t{}\n\txor\tdword ptr [esp],\t{}\n".format("0x"+xorer.encode("hex"), "0x"+xorstr(xorer, data_piece).encode("hex"))
            else:
                ret += "\tpush\t{}\n".format("0x"+data_piece.encode("hex"))
        ret += "\tmov\t{},\tesp\n".format(register)
        return ret

def CreateAsm(sc,v1,v2,v3,v4,v5,v6):
    sType, syscall = sc.split(":")
    shellcode = ""
    gen_queue = []
    register_inits = []
    if sc:
        scType, sc = sc.split(":")
        register_inits.append((sc, "eax", scType))
    if v1:
        v1Type, v1v = v1.split(":")
        register_inits.append((v1v, "ebx", v1Type))
    if v2:
        v2Type, v2v = v2.split(":")
        register_inits.append((v2v, "ecx", v2Type))
    if v3:
        v3Type, v3v = v3.split(":")
        register_inits.append((v3v, "edx", v3Type))
    if v4:
        v4Type, v4v = v4.split(":")
        register_inits.append((v4v, "esi", v4Type))
    if v5:
        v5Type, v5v = v5.split(":")
        register_inits.append((v5v, "edi", v5Type))
    if v6:
        v6Type, v6v = v6.split(":")
        register_inits.append((v6v, "ebp", v6Type))
    for reg_init in register_inits:
        if reg_init[2] == "byte[]":
            gen_queue.append(reg_init)
            register_inits.remove(reg_init)
    for reg_init in register_inits:
        gen_queue.append(reg_init)
    #print(gen_queue)
    for genValue in gen_queue:
        buffer, register, bufferType = genValue
        shellcode += validateBytes(buffer, register, bufferType)
    return shellcode+"\tint\t0x80\n"

def convertShellcodeArray(array):
    if type(array) == str:
        buf = []
        buf.append(array)
        array = buf
    syscall = array[0]             # eax
    var1 = None                    # ebx
    var2 = None                    # ecx
    var3 = None                    # edx
    var4 = None                    # esi
    var5 = None                    # edi
    var6 = None                    # ebp

    if len(array) >= 2:
        var1 = array[1]
        if len(array) >= 3:
            var2 = array[2]
            if len(array) >= 4:
                var3 = array[3]
                if len(array) >= 5:
                    var4 = array[4]
                    if len(array) >= 6:
                        var5 = array[5]
                        if len(array) == 7:
                            var6 = array[6]
    return CreateAsm(syscall, var1, var2, var3, var4, var5, var6)

def parse_arguments(inp):
	isstring = False
	args = []
	buffer = ""
	for c in inp:
		if c == " " and not isstring:
			args.append(buffer)
			buffer = ""
		elif c == "\"":
			if isstring:
				isstring = False
			else:
				isstring = True
		else:
			buffer += c
	if buffer:
		args.append(buffer)
	return args

def interactiveShellGen():
    final = ""
    while True:
        cmd = raw_input(">>> ").lower()
        if cmd == "syscall":
            arguments = raw_input("----> ")
            arguments = parse_arguments(arguments)
            if len(arguments) >= 1:
                bType, bValue = arguments[0].lower().split(":")
                if bType == "hex":
                    bValue = bValue.replace("0x", "")
                    bValue = "{} <=> ( {} )".format(struct.unpack("B", bValue.decode("hex"))[0], "0x"+bValue)
                elif bType == "int":
                    bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                elif bType == "byte[]":
                    bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                print("Syscall \t==>\t{}".format(bValue))
                if len(arguments) >= 2:
                    bType, bValue = arguments[1].lower().split(":")
                    if bType == "hex":
                        bValue = bValue.replace("0x", "")
                        bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                    elif bType == "int":
                        bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                    elif bType == "byte[]":
                        bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                    print("Argument1\t==>\t{}".format(bValue))
                    if len(arguments) >= 3:
                        bType, bValue = arguments[2].lower().split(":")
                        if bType == "hex":
                            bValue = bValue.replace("0x", "")
                            bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                        elif bType == "int":
                            bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                        elif bType == "byte[]":
                            bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                        print("Argument2\t==>\t{}".format(bValue))
                        if len(arguments) >= 4:
                            bType, bValue = arguments[3].lower().split(":")
                            if bType == "hex":
                                bValue = bValue.replace("0x", "")
                                bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                            elif bType == "int":
                                bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                            elif bType == "byte[]":
                                bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                            print("Argument3\t==>\t{}".format(bValue))
                            if len(arguments) >= 5:
                                bType, bValue = arguments[4].lower().split(":")
                                if bType == "hex":
                                    bValue = bValue.replace("0x", "")
                                    bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                                elif bType == "int":
                                    bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                                elif bType == "byte[]":
                                    bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                                print("Argument4\t==>\t{}".format(bValue))
                                if len(arguments) >= 6:
                                    bType, bValue = arguments[5].lower().split(":")
                                    if bType == "hex":
                                        bValue = bValue.replace("0x", "")
                                        bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                                    elif bType == "int":
                                        bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                                    elif bType == "byte[]":
                                        bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.split(",")))
                                    print("Argument5\t==>\t{}".format(bValue))
                                    if len(arguments) > 6:
                                        bType, bValue = arguments[6].lower().split(":")
                                        if bType == "hex":
                                            bValue = bValue.replace("0x", "")
                                            bValue = "{} <=> ( {} )".format(str(int("0x"+bValue.decode("hex"))), "0x"+bValue)
                                        elif bType == "int":
                                            bValue = "{} <=> ( {} )".format(str(hex(int(bValue))), bValue)
                                        elif bType == "byte[]":
                                            bValue = "[{}]".format(", ".join('"'+value+'"' for value in bValue.spli(",")))
                                        print("Argument6\t==>\t{}".format(bValue))
            final += convertShellcodeArray(arguments)
        elif cmd == "raw":
            sc = ""
            confirmed = False
            confirmed0= False
            while not confirmed and not confirmed0:
                 instructions = raw_input("-> ")
                 if not instructions:
                     if confirmed0:
                         confirmed = True
                     else:
                         confirmed0 = True
                 else:
                     confirmed0 = False
                     confirmed = False
                     sc += "\n"+instructions+"\n"
            final += sc
        elif cmd == "generate":
            print("Generated shellcode:\n\n{}".format(final))
            sys.exit()

parser = argparse.ArgumentParser(description="Exploit generation tool by Format_HDD")
parser.add_argument('--pattern', dest="patternAction", nargs="*", help="create/check valueOne valueTwo")
parser.add_argument('--generate', dest="syscallName", nargs="*", help="Shellcode to generate")
args = parser.parse_args()

if args.patternAction and len(args.patternAction) == 2 and args.patternAction[0] == "create":
    try:
        pattern_size = int(args.patternAction[1])
    except:
        parser.print_help()
        sys.exit()
    print createPattern(pattern_size, parser)
elif args.patternAction and len(args.patternAction) == 3 and args.patternAction[0] == "check":
    try:
        pattern_size = int(args.patternAction[1])
    except:
        parser.print_help()
        sys.exit()
    try:
        pattern_address = args.patternAction[2]
    except:
        parser.print_help()
        sys.exit()

    print checkPattern(pattern_size, pattern_address, parser)
elif args.syscallName:
	if type(args.syscallName) == str:
		if args.syscallName.lower() == "interactive":
			interactiveShellGen()
			sys.exit()
	elif args.syscallName[0].lower() == "interactive":
		interactiveShellGen()
		sys.exit()
	print convertShellcodeArray(args.syscallName)
else:
    parser.print_help()
